package mock_engine

import (
	"context"
	"sync"

	"github.com/argoproj/gitops-engine/pkg/cache"
	"github.com/argoproj/gitops-engine/pkg/engine"
	enginesync "github.com/argoproj/gitops-engine/pkg/sync"
	"github.com/argoproj/gitops-engine/pkg/sync/common"
	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
)

// GitOpsEngineFactory is a copy of agentk.GitOpsEngineFactory to break cyclic dependency.
type GitOpsEngineFactory interface {
	New(engineOpts []engine.Option, cacheOpts []cache.UpdateSettingsFunc) engine.GitOpsEngine
}

var (
	_ engine.GitOpsEngine = &ThreadSafeGitOpsEngine{}
	_ GitOpsEngineFactory = &ThreadSafeGitOpsEngineFactory{}
)

// ThreadSafeGitOpsEngineFactory is a wrapper for GitOpsEngineFactory to make it thread safe.
// For use with tests - mocks, generated by GoMock, are not thread safe.
type ThreadSafeGitOpsEngineFactory struct {
	mutex         sync.Mutex
	EngineFactory GitOpsEngineFactory
}

func (f *ThreadSafeGitOpsEngineFactory) New(engineOpts []engine.Option, cacheOpts []cache.UpdateSettingsFunc) engine.GitOpsEngine {
	f.mutex.Lock()
	defer f.mutex.Unlock()
	return &ThreadSafeGitOpsEngine{
		Mutex:    &f.mutex,
		Delegate: f.EngineFactory.New(engineOpts, cacheOpts),
	}
}

type ThreadSafeGitOpsEngine struct {
	// Mutex is a pointer to allow to share a mutex between mocks.
	// This is required because all mocks share a *gomock.Controller instance which is what we are protecting.
	Mutex    *sync.Mutex
	Delegate engine.GitOpsEngine
}

func (f *ThreadSafeGitOpsEngine) Run() (engine.StopFunc, error) {
	f.Mutex.Lock()
	defer f.Mutex.Unlock()
	return f.Delegate.Run()
}

func (f *ThreadSafeGitOpsEngine) Sync(ctx context.Context, resources []*unstructured.Unstructured, isManaged func(r *cache.Resource) bool, revision string, namespace string, opts ...enginesync.SyncOpt) ([]common.ResourceSyncResult, error) {
	f.Mutex.Lock()
	defer f.Mutex.Unlock()
	return f.Delegate.Sync(ctx, resources, isManaged, revision, namespace, opts...)
}
